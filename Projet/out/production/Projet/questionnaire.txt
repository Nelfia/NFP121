% NOM Prénom (numéro) : ... (...)


**Remarque :** Ce fichier est au format Markdown.  À partir de lui, on peut
produire un pdf, un odt, un docx, du html, etc.  Par exemple, avec pandoc on
pourra faire :

~~~
pandoc --toc -o questionnaire.pdf questionnaire.txt
pandoc --toc -s -o questionnaire.html questionnaire.txt
~~~


# Points non traités du sujet

...


# Traitements


## Quelle est la classe du traitement choisi ?

J'ai quelques idées, mais sans certitudes sur l'originalité de ces dernières. Par exemple: calculer la moyenne des
valeurs


## Pourquoi avoir fait de traitement une classe abstraite et non une interface ?

Pour pouvoir factoriser un maximum de code concernant les traitements et pouvoir imposer certaines méthodes à ses
sous-classes.
Cela permet également de lui déléguer la responsabilité des traitements en faisant appel à ses méthodes concrètes.


## Pourquoi certaines méthodes sont déclarées `final` ?

Elles ne peuvent pas être redéfinies par les sous-classes, ce qui permet justement de leur imposer ces méthodes
telles qu'elles sont écrites.


## La classe Traitement est abstraite alors qu'elle ne contient pas de méthodes abstraites. Pourquoi ?

Elle n'est pas instanciable et spécifie un comportement. La classe Traitement ne s'occupe que de la gestion de
traitements, elle ne les réalise pas. Elle oblige donc les "utilisateurs" à définir des sous-classes qui
réaliseront les traitements concrets.


## Est-ce que de faire de Traitement une classe abstraite est vraiment logique ici ?

Oui, pour toutes les raison évoquées ci-dessus: on évite de dupliquer du code, on s'assure d'avoir une gestion
commune des traitements, on impose à chaque traitement des méthodes communes...


## Pour le traitement Normaliseur, quels autres traitements avez-vous utilisés et comment ?

- Donnees : pour enregistrer toutes les données dans une List
- Max : pour récupérer la valeur maximum et pour récupérer la valeur minimum.

On les utilise dans la méthode traiter pour pouvoir appliquer un premier traitement sur l'intégralité des données
lues. Puis on récupère les résultats de ces traitement dans GestionFinDeLotLocal car nous avons besoin que toutes
les données aient subies les différents traitements avant de pouvoir les normaliser.


## Quelles modifications avez-vous été obligés de faire sur la classe Position ?

Nous avons été obligé de surcharger equals() qui nous permet de comparer les valeurs logiques des éléments que nous
estimons représentatifs de 2 objets pour pouvoir dire qu'ils sont équivalents. Sans cela, nous ne faisons que
comparer leurs valeurs physiques (adresse en mémoire physique) qui sont nécessairement différentes car chaque
Position est instanciée avec le mot-clé "new" qui créé une nouvelle adresse en mémoire.


# Remarques sur Swing

...


# Remarques sur l'Introspection

C'est absolument génial! XD


# Remarques sur XML

## Lecture d'un document XML

...


## Production d'un document XML

Génération avec JDOM2 selon la dtd generateur.dtd.
Choix d'enregistrer les données en conservant toutes les données brutes. IL aurait été possible de les enregistrer avec
toutes les valeurs par position, mais il était plus simple de le lire (et de le générer) ainsi.


# Principaux choix faits

- Ajout d'une classe abstraite ExtractionSourceAbstraite : permet de factoriser une partie du code
- Ajout d'une classe ExtractionTxtT1 : permet d'extraire les données d'un fichier texte de type 1
- Ajout d'une classe ExtractionTxtT2 : permet d'extraire les données d'un fichier texte de type 1
Il aurait été possible de faire l'extraction différemment, par exemple en définissant des méthodes qui extraient les
données en fonction du type de fichier et de son format (ex: txt type 1 ou txt type 2).


# Critiques de l'architecture proposée et améliorations possibles

...


# Difficultés rencontrées

Il m'a fallu un certain temps pour réaliser le Normaliseur qui est la premier traitement où nous devons changer de
façon de procéder puisqu'il est réalisé en 2 fois. Je n'ai pas terminé et quelque chose me dit que le pire reste à
venir.

